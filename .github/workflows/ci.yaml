name: CI

on:
  push:
    branches: [ main ]          # dev deploy on merges to main
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  deploy-dev:
    runs-on: ubuntu-latest
    environment: dev
    env:
      AWS_REGION: ${{ vars.AWS_REGION }}
      ECR_REGISTRY_HOST: ${{ vars.ECR_REGISTRY_HOST }}   # host only
      ECR_REPO: ${{ vars.ECR_REPO }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Configure AWS (dev)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR (dev)
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
          | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY_HOST }}

      - name: Compute image tag
        id: meta
        run: |
          TAG="dev-${{ github.sha }}"
          IMAGE="${{ env.ECR_REGISTRY_HOST }}/${{ env.ECR_REPO }}:${TAG}"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          echo "Will use: $IMAGE"

      - name: Check if tag exists
        id: ecrcheck
        run: |
          if aws ecr describe-images \
               --repository-name "${{ env.ECR_REPO }}" \
               --image-ids imageTag="${{ steps.meta.outputs.tag }}" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Build & push (if missing)
        if: steps.ecrcheck.outputs.exists == 'false'
        run: |
          docker build -t "${{ steps.meta.outputs.image }}" app
          docker push "${{ steps.meta.outputs.image }}"

      - name: Terraform init/plan/apply (dev)
        working-directory: terraform
        env:
          TF_VAR_env: dev
          TF_VAR_image: ${{ steps.meta.outputs.image }}
          TF_VAR_aws_region: ${{ env.AWS_REGION }}
        run: |
          rm -rf .terraform
          terraform init -input=false -reconfigure -backend-config=backend/dev.hcl
          terraform plan -input=false -var-file=tfvars/dev.tfvars -out=tfplan
          terraform apply -input=false -auto-approve tfplan

  promote-and-deploy-prod:
    runs-on: ubuntu-latest
    needs: deploy-dev
    environment: prod
    env:
      # prod env
      AWS_REGION: ${{ vars.AWS_REGION }}
      PROD_ECR_HOST: ${{ vars.ECR_REGISTRY_HOST }}
      ECR_REPO: ${{ vars.ECR_REPO }}
      PROD_ROLE_ARN: ${{ vars.AWS_ROLE_ARN }}
      # dev (source) — repo-level variables (or move into prod environment if preferred)
      DEV_AWS_REGION: ${{ vars.AWS_REGION }}
      DEV_ECR_HOST: ${{ vars.DEV_ECR_HOST }}
      DEV_ROLE_ARN: ${{ vars.DEV_AWS_ROLE_ARN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Compute tags/URIs
        id: tags
        run: |
          DEV_TAG="dev-${{ github.sha }}"
          PROD_TAG="prod-${{ github.sha }}"
          echo "dev_tag=$DEV_TAG" >> $GITHUB_OUTPUT
          echo "prod_tag=$PROD_TAG" >> $GITHUB_OUTPUT
          echo "prod_image=${{ env.PROD_ECR_HOST }}/${{ env.ECR_REPO }}:${PROD_TAG}" >> $GITHUB_OUTPUT

      # 1) Assume DEV role, pull the built image from dev ECR
      - name: Configure AWS (dev)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.DEV_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Docker login to DEV ECR & pull
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
          | docker login --username AWS --password-stdin ${{ env.DEV_ECR_HOST }}
          docker pull "${{ env.DEV_ECR_HOST }}/${{ env.ECR_REPO }}:${{ steps.tags.outputs.dev_tag }}"

      # 2) Assume PROD role, tag & push to prod ECR (no rebuild)
      - name: Configure AWS (prod)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.PROD_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Docker login to PROD ECR & push
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
          | docker login --username AWS --password-stdin ${{ env.PROD_ECR_HOST }}
          docker tag  "${{ env.DEV_ECR_HOST }}/${{ env.ECR_REPO }}:${{ steps.tags.outputs.dev_tag }}" \
                      "${{ steps.tags.outputs.prod_image }}"
          docker push "${{ steps.tags.outputs.prod_image }}"

      - name: Define image tags
        id: img
        run: |
          echo "DEV_IMAGE=${{ vars.DEV_ECR_HOST }}/${{ vars.ECR_REPO }}:dev-${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "PROD_IMAGE=${{ vars.PROD_ECR_HOST }}/${{ vars.ECR_REPO }}:prod-${{ github.sha }}" >> $GITHUB_OUTPUT

      - name: Check if prod tag already exists
        id: prod_tag
        run: |
          set -e
          if aws ecr describe-images \
              --repository-name "${{ vars.ECR_REPO }}" \
              --image-ids imageTag="prod-${{ github.sha }}" \
              --region "${{ vars.PROD_AWS_REGION }}" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Promote image to prod (pull→tag→push) if missing
        if: steps.prod_tag.outputs.exists == 'false'
        run: |
          # Pull built image from DEV
          docker pull "${{ steps.img.outputs.DEV_IMAGE }}"
          # Retag for PROD
          docker tag "${{ steps.img.outputs.DEV_IMAGE }}" "${{ steps.img.outputs.PROD_IMAGE }}"
          # Push to PROD once (immutable)
          docker push "${{ steps.img.outputs.PROD_IMAGE }}"

      - name: Terraform apply (prod)
        env:
          TF_VAR_env: prod
          TF_VAR_image: ${{ steps.img.outputs.PROD_IMAGE }}
          TF_VAR_aws_region: ${{ vars.PROD_AWS_REGION }}
        run: |
          terraform init -input=false -reconfigure -backend-config=backend/prod.hcl
          terraform plan -input=false -out=tfplan
          terraform apply -input=false -auto-approve tfplan
