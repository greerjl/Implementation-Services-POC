name: CI

on:
  push:
    branches: [ main ]        # dev deploy on merges to main
  pull_request:
    branches: [ main ]        # optional: run pipeline on PRs (TF can still plan)
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  deploy-dev:
    runs-on: ubuntu-latest
    # Loads Environment-scoped variables & enforces any protection rules
    environment: dev

    # Use your Environment variables as job envs
    env:
      AWS_REGION: ${{ vars.AWS_REGION }}
      ECR_REGISTRY: ${{ vars.ECR_REGISTRY }}   # host ONLY (no /repo)
      ECR_REPO: ${{ vars.ECR_REPO }}

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ vars.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
        
      - name: Who am I?
        run: aws sts get-caller-identity

      - name: Bucket region
        run: aws s3api get-bucket-location --bucket dev-terraform-state-datadog-demo-jb

      - name: List prefix (should NOT be AccessDenied)
        run: aws s3 ls s3://dev-terraform-state-datadog-demo-jb/dev/ || true

      - name: Head state object (404 is OK; AccessDenied is not)
        run: aws s3api head-object --bucket dev-terraform-state-datadog-demo-jb --key dev/terraform.tfstate || true

      - name: Describe lock table
        run: aws dynamodb describe-table --table-name dev-terraform-locks

      - name: Validate required variables
        run: |
          test -n "${{ env.AWS_REGION }}" || { echo "Missing AWS_REGION"; exit 1; }
          test -n "${{ env.ECR_REGISTRY }}" || { echo "Missing ECR_REGISTRY"; exit 1; }
          test -n "${{ env.ECR_REPO }}" || { echo "Missing ECR_REPO"; exit 1; }
          # ECR_REGISTRY must not include a repo suffix
          if [[ "${{ env.ECR_REGISTRY }}" == */* ]]; then
            echo "ECR_REGISTRY must be host only (no /${{ env.ECR_REPO }})."; exit 1;
          fi

      - name: Login to ECR (safe)
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} \
          | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}

      # Compute the canonical image ref once and reuse it everywhere
      - name: Compute image tag
        id: meta
        run: |
          TAG="dev-${{ github.sha }}"
          IMAGE="${{ env.ECR_REGISTRY }}/${{ env.ECR_REPO }}:${TAG}"
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Will use image: $IMAGE"

      # Option A: skip push if the tag already exists (immutability-friendly)
      - name: Check if image tag exists in ECR
        id: ecrcheck
        run: |
          if aws ecr describe-images \
               --repository-name "${{ env.ECR_REPO }}" \
               --image-ids imageTag="${{ steps.meta.outputs.tag }}" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Image tag already exists; will skip build/push."
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Image tag not found; will build and push."
          fi

      - name: Build & push image (only if missing)
        if: steps.ecrcheck.outputs.exists == 'false'
        run: |
          docker build -t "${{ steps.meta.outputs.image }}" app
          docker push "${{ steps.meta.outputs.image }}"

      # Terraform deploy (always uses the same image reference, pushed earlier or pre-existing)
      - name: Terraform init / plan / apply (dev)
        working-directory: terraform
        env:
          TF_VAR_env: dev
          TF_VAR_image: ${{ steps.meta.outputs.image }}
          TF_VAR_aws_region: ${{ env.AWS_REGION }}
        run: |
          terraform init -input=false
          terraform plan -input=false -out=tfplan
          terraform apply -input=false -auto-approve tfplan
